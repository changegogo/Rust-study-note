**说明**:Rust中的每一个引用都有其**生命周期**(`lifetime`)，也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多重可能类型时必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以Rust需要使用泛型生命周期参数来注明引用的关系，这样就能确保运行时实际使用的引用绝对是有效的。

生命周期的概念从某种程度上说不同于其它语言中类似的工具，毫无疑问这是Rust最与众不同的功能。

生命周期的主要目的是避免悬垂引用，悬垂引用会导致程序引用非预期引用的数据。

尝试使用离开作用域的值得引用
```rust
let r;
{
    let x = 5;
    r = &x;
}
println!("r: {}", r);
```
外部作用域声明了一个没有初值的变量 `r` ，而内部作用域声明了一个初值为5的变量 `x` 。在内部作用域中，尝试将 `r` 的值设置为一个 `x` 的引用。接着在内部作用域结束后，尝试打印出r的值。这段代码不能编译因为r引用的值在尝试使用之前就离开了作用域，错误信息如下：
```rust
error[E0597]: `x` does not live long enough
  --> src\main.rs:26:13
   |
26 |         r = &x;
   |             ^^ borrowed value does not live long enough
27 |     }
   |     - `x` dropped here while still borrowed
28 |     println!("r: {}", r);
   |                       - borrow later used here
```
变量x没有"存活的足够久"。其原因是x在内部作用域结束时就离开了作用域。但是r在外部作用域仍是有效的；作用域越大就说它"存在的越久"。Rust是如何决定这段代码不被允许，得益于**借用检查器**。
## 借用检查器
Rust编译器有一个**借用检查器**(`borrow checker`),它比较作用域来确保所有的借用都是有效的。
带有变脸生命周期的注释：
```rust
{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}
```
上面将 `r` 的生命周期标记为 `'a` 并将 x 的生命周期标记为 `'b`。内部的 `'b` 块比外部的生命周期 `'a` 小。在编译时，Rust比较这两个生命周期的大小，发现 `r` 拥有生命周期 `'a` ，不过它引用了一个拥有生命周期 `'b` 的对象。因为生命周期 `'b` 比生命周期 `'a` 要小，被引用的对象比引用者存在的时间短，所有程序被拒绝编译。

没有产生悬垂引用且可以正确编译的例子：
```rust
{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
```
上面 `x` 拥有生命周期 `'b` ，比 `'a` 要大。这就意味着 `r` 可以引用 `x` ：Rust知道 `r` 中的引用在 `x` 有效的时候也总是有效的。
## 函数中的生命周期
定义如下 `longest` 函数:
```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
上面函数无法编译，出现如下有关生命周期的错误：
```rust
error[E0106]: missing lifetime specifier
  --> src\main.rs:22:36
   |
22 | fn largestStr(x: &str, y: &str) -> &str {
   |                  ----     ----     ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`    
help: consider introducing a named lifetime parameter
   |
22 | fn largestStr<'a>(x: &'a str, y: &'a str) -> &'a str {
   |              ++++     ++          ++          ++
```
提示文本中显示返回值需要一个生命周期参数，因为Rust不知道将要返回的引用是 `x` 或 `y` 。实际情况下，我们也不知道，因为函数体中 `if` 块返回一个 `x` 的引用而 `else` 块返回一个 `y` 的引用。

当我们定义这个函数的时候，不知道传递给函数的具体值，所以也不知道到底是if还是else会被执行。也不知道传入的引用的具体生命周期，所以也就不能通过观察作用域来确定返回的引用是否总是有效。借用检查器同样也无法确定，因为它不知道x和y的生命周期是如何与返回值的生命周期相关联的。为了修复这个错误，我们将增加生命周期参数来定义引用间的关系以便借用检查器可以进行分析。
## 生命周期注解语法
生命周期注解并不改变任何引用的生命周期的长短。与当函数签名中指定了泛型类型参数后就可以接受任何类型一样，当指定了生命周期后函数也能接受任何生命周期的引用。生命周期注解描述了多个引用生命周期相互的关系，而不影响其生命周期。

生命周期参数名称表示形式
```rust
&i32        // 引用
&'a i32     // 带有显式生命周期的引用
&'a mut i32 // 带有显式生命周期的可变引用
```
## 深入理解生命周期
指定生命周期参数的正确方式依赖函数实现的具体功能。例如，将longest函数的实现修改为总是返回第一个参数而不是最长的字符串slice，就不需要为参数y指定一个生命周期。如下代码编译正确：
```rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```
在这个例子中，为参数 `x` 和返回值指定了生命周期参数 `'a`，不过没有为参数 `y` 指定，因为 `y` 的生命周期与参数 `x` 和返回值的生命周期没有任何关系。

当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。如果返回的引用没有指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。如下代码不可编译：
```rust
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.ad_str()
}
```
即便我们为返回值指定了生命周期参数 'a ，这个代码却编译失败了，因为返回值的生命周期与参数完全没有关联。

出现的问题时result在longest函数的结尾将离开作用域并被清理，而我们尝试从函数返回一个result的引用。无法指定生命周期参数来改变悬垂引用，而且Rust也不允许我们创建一个悬垂引用。在这种情况下，最好的解决方案是返回一个所有权的数据而不是一个引用，这样函数调用者就需要负责清理这个值了。

综上，生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的。一旦形成了某种关联，Rust就有了足够的信息来允许内存安全的操作并阻止会产生悬垂引用亦或是违反内存安全的行为。

## 结构体定义中的生命周期注解
```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}
```
类似于泛型参数类型，必须在结构体名称后面的尖括号中声明生命周期参数，以便在结构体定义中使用生命周期参数。这个注解意味着 `ImportantExcerpt` 的实力不能比其 `part` 字段中的引用存在的更久。
## 生命周期省略（Lifetime Elision）
每一个引用都有一个生命周期，而且我们需要为那些使用了引用的函数或结构体指定生命周期。某些情况下生命周期参数可以省略，例如下面代码：
```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```
省略前的样子：
```rust
fn first_word<'a>(s: &'a str) -> &'a str {
```
省略的原因是可预测的并且遵循几个明确的模式，被编码进Rust引用分析的模式被称为**生命周期省略规则**（`lifetime elision rules`）。

函数或方法的参数的生命周期被称为**输入生命周期**(`input lifetime`)，而返回值的生命周期是**输出生命周期**(`output lifetime`)。

编译器采用三条规则来判断引用何时不需要明确的注解：
1. 这条适用于输入生命周期，每一个引用的参数都有自己的生命周期参数；
2. 这条适用于输出生命周期，如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：`fn foo<'a>(x: &'a i32) -> &'a i32`；
3. 这条也适用于输出生命周期，如果方法有多个生命周期参数并且其中一个参数是 `&self` 或 `&mut self`,说明是个对象的方法（method），那么所有输出生命周期参数被赋予 `self` 的生命周期。
## 方法定义中的生命周期注解
```rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```
`impl` 之后和类型名称之后的生命周期参数是必要的，不过因为第一条生命周期规则我们并不必须标注 self 引用的生命周期。

下面是一个适用于第三条生命周期省略规则的例子：
```rust
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
```
这里有两个输入生命周期，所以 Rust 应用第一条生命周期省略规则并给予 &self 和 announcement 他们各自的生命周期。接着，因为其中一个参数是 &self，返回值类型被赋予了 &self 的生命周期，这样所有的生命周期都被计算出来了。
## 静态生命周期
`'static`，其生命周期存活于整个程序期间。所有的字符串字面值都拥有 `'static` 生命周期：
```rust
let s: &'static str = "I hava a static lifetime.";
```
这个字符串的文本被直接储存在程序的二进制文件中而这个文件总是可用的，因此所有的字符串字面值都是 `'static` 的。

大部分情况，代码中的问题是尝试创建一个悬垂引用或者可用的生命周期不匹配，请解决这些问题而不是指定一个 `'static` 的生命周期。
## 结合泛型类型参数、trait bounds和生命周期
下面是一个在同一函数中指定泛型类型参数、trait bounds和生命周期的语法
```rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
    where T: Display 
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```
## 总结
- 泛型类型参数意味着代码可以适用于不同的类型
- trait和trait bounds保证了即使类型是泛型的，这些类型也会拥有所需要的行为
- 生命周期注解所指定的引用生命周期之间的关系保证了这些灵活多变的代码不会出现悬垂引用

上面的一切都发生在编译时所以不会影响运行时的效率。