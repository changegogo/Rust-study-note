**说明**:可以使用泛型为像函数签名或结构体这样的项创建定义，这样就可以用于多种不同的具体数据类型。
## 在函数定义中使用泛型
当使用泛型定义函数时，本来在函数签名中指定参数和返回值类型的地方，改用泛型来表示。采用这种技术，使得代码适应性更强，从而为函数的调用者提供更多的功能，同时也避免了代码的重复。

为了定义泛型版本的函数，类型参数声明位于函数名称与参数列表中间的尖括号<>中，如下：
```rust
fn largest<T>(list: &[T]) -> T {
```
具体例子：
```rust
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}
```
## 结构体定义中的泛型
同样也使用<>语法来定义结构体，可以包含一个或多个泛型参数类型字段，例如：
```rust
struct Point<T> {
    x: T,
    y: T,
}
```
如果包含2种类型：
```rust
struct Point<T, U> {
    x: T,
    y: U,
}
```
可以定义任意多的泛型类型参数，但是太多的话，代码将难以阅读和理解，如果确实需要许多泛型时，可能表明代码需要重构，分解成更小的结构。
## 枚举定义中的泛型
```rust
enum Option<T> {
    Some(T),
    None,
}
```
`Option<T>`是一个拥有泛型 `T` 的枚举，它有两个成员: `Some`, 存放一个类型 `T` 的值，和不存在任何值的 `None`。通过 `Option<T>` 枚举可以表达一个可能的值的抽象概念，同时因为 `Option<T>` 是泛型的，无论这个可能的值是什么类型都可以使用这个枚举。

枚举也能有多个泛型类型，例如 `Result<T, E>`
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
`Result` 枚举有两个泛型类型，`T` 和 `E`。`Result` 有两个成员： `Ok`，存放一个类型 `T` 的值，而 `Err` 则存放一个类型 `E` 的值。在打开文件的方式代码中：当成功打开文件的时候，`T` 对应的是   `std::fs::File` 类型， 而打开文件出现问题时， `E` 的值则是 `std::io::Error` 类型。

**当意识到代码中定义了多个结构体或枚举，他们不一样的地方只是其中的值的类型的时候，不妨通过泛型类型来减少重复。**
## 方法定义中的泛型
一、定义结构体 `Point<T>` ,并在其上实现名为 `x` 的方法。
```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}
```
上面代码注意必须在 `impl` 后面声明 `T`，这样就可以在 `Point<T>` 上实现的方法中使用它了。在 `impl` 之后声明泛型 `T` ，这样Rust就知道 `Point` 的尖括号中的类型时泛型而不是具体类型。

也可以选择为 `Point<f32>`实例实现方法，而不是为泛型 `Point` 实例。如下展示了一个没有在 `impl` 之后的尖括号声明泛型的例子，这里使用了一个具体的类型， `f32` ：
```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```
上面代码意味着 `Point<f32>` 类型会有一个方法 `distance_from_origin` ,而其它T不是 `f32` 类型的 `Point<T>` 实例则没有定义此方法。

## 结构体泛型和方法泛型不一样
结构体定义中的泛型类型参数并不总是与结构体方法签名中的泛型时同一类型。
```rust
struct Point0<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point0<T, U> {
    fn mixup<V, W>(self, other: Point0<V, W>) -> Point0<T, W> {
        Point0 {
            x: self.x,
            y: other.y,
        }
    }
}
```
上面代码展示了一些泛型通过 `impl` 声明而另一些通过方法定义声明的情况。这里泛型参数 `T` 和 `U` 声明于 `impl` 之后，因为它们与结构体定义相对应。而泛型参数 `V` 和 `W` 声明于 `fn mixup` 之后，因为它们只是相对于方法本身的。
## 泛型代码的运行时性能
Rust通过在编译时进行泛型代码的**单态化**(*monomorphization*)来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。

我们使用泛型编写不重复的代码，而Rust将会为每一个实例编译其特定类型的代码，所以使用泛型时没有运行时开销。