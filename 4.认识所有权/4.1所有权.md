## Rust的核心功能之一是所有权（ownership）
所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制（java、Go），在程序运行时不断地寻找不再使用的内存；在另一些语言中（c、c++），程序必须亲自分配（allocate）和释放（free）内存。

Rust则选择了第三种方式:通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序。

所有权的工作:跟踪那部分代码正在使用堆上的数据，最大限度地减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。理解了所有权，就不需要考虑栈和堆了，明白了所有权的存在就是为了管理堆内存。
## 所有权规则:
1. `Each value in Rust has a variable that's called tis owner.` Rust中的每一个值都有一个被称为其所有者（owner）的变量。
2. `There can only be one owner at a time.` 值在任一时刻有且仅有一个所有者。
3. `When the owner goes out of scope,the value will be dropped.` 当所有者（变量）离开作用域，这个值将被丢弃。

## 程序都是如何释放内存的方式：
在有垃圾回收（garbage collection，GC）的语言中，GC记录并清除不再使用的内存，程序员不需要关心。没有GC的话，识别出不再使用的内存并调用代码显式释放是程序员的责任，跟请求内存的时候一样。从历史的角度上说正确的处理内存回收曾经是一个困难的编程问题。忘记回收会浪费内存，过早回收，会出现无效变量，重复回收，这也是bug。我们需要精确的为一个allocate配对一个free。

Rust释放内存的策略和其它语言有很大的不同，新奇并富有魅力：内存在拥有它的变量离开作用域后就被自动释放。当变量离开作用域，Rust为我们调用一个特殊的函数。这个函数叫做drop，Rust在结尾的}处自动调用drop。

> 注意：在C++中，这种item在生命周期结束时释放资源的模式被称为资源获取即初始化(Resource Acquisition Is Initialization(RAII))。
## 变量与数据交互的方式（一）：移动
浅拷贝（shallow copy）深拷贝（`deep copy`）

Rust中同时使一个变量无效，这个操作被称为移动（`move`）。

Rust永远也不会自动创建数据的“深拷贝”。因此，自动的复制可以被认为对运行时性能影响较小。
## 变量与数据的交互的方式（二）：克隆
如果确实需要深度复制堆上的数据，而不仅仅是栈上的数据，可以使用clone的通用函数。
```rust
let s1 = String::from("hello");
let s2 = s1.clone();
println!("s1={}, s2={}", s1, s2)
```
当出现`clone`调用时，应该知道一些特定的代码被执行而且这些代码可能相当消耗资源。
## 只在栈上的数据：拷贝
像整型这样的编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。

**疑问：这句话还不明白**

Rust有一个叫做`Copy` trait的特殊注解，可以用在类似整型这样的存储在栈上的类型上。如果一个类型实现了`Copy` trait，那么一个旧的变量在将其赋值给其它变量后仍然可用。Rust不允许自身或其任何部分实现了`Drop` trait的类型使用`Copy` trait。如果我们对其值离开作用域时需要特殊处理的类型使用`Copy`注解，将会出现一个编译时错误。
下面类型实现了`Copy`类型

- 所有整数类型，比如`u32`
- 布尔类型，`bool`，它的值是`true`和`false`
- 所有浮点类型，比如`f64`
- 字符类型，`char`
- 元祖，当且仅当其包含的类型也都实现`Copy`的时候。比如`(i32, i32)`实现了`Copy`，但是`(i32, String)`就没有
## 所有权与函数
将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动(`move`)或者复制(`copy`)，就像赋值语句一样。

变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值得变量离开作用域时，其值将通过`drop`被清理掉，除非数据被移动为另一个变量所有。
